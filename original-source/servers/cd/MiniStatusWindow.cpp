/*------------------------------------------------------------*/
//
//	File:		MiniStatusWindow.cpp
//
//	Written by:	Robert Polic
//
//	Copyright 2000, Be Incorporated
//
/*------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <Roster.h>
#include <Bitmap.h>
#include <Deskbar.h>

#include "cd.h"
#include "MiniStatusWindow.h"


#define kHOR_MARGIN			  4		// hor. gap between frame and tip
#define kVER_MARGIN			  3		// ver. gap between frame and tip
#define kICON_WIDTH			 15
#define kICON_HEIGHT		  9


const rgb_color kVIEW_COLOR			= {255, 203, 0, 255};	// view background color (light yellow)
const rgb_color kLIGHT_VIEW_COLOR	= {255, 255, 80, 255};	// top left frame highlight
const rgb_color kDARK_VIEW_COLOR	= {175, 123, 0, 255};	// bottom right frame highlight
const rgb_color kTEXT_COLOR			= {0, 0, 0, 255};		// text color (black)


// strings that need to be localized
const char* kEMPTY		= "Device is empty";
const char* kOPEN		= "Tray is open";
const char* kSTOPPED	= "Stopped";
const char* kTRACK		= "Track";
const char* kUNKNOWN	= "Device state is unknown";


const unsigned char	kPLAYING_ICON[] =
{
	0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x18, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x18, 0x00, 0x00, 0x00, 0x00, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x18, 0x00, 0x00, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

const unsigned char kPAUSED_ICON[] =
{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0x18, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x19, 0x19, 0xff, 0xff, 0x18, 0x19, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

const unsigned char kRIPPING_ICON[] =
{
	0xff, 0xff, 0xff, 0xff, 0x18, 0x18, 0x18, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x18, 0xeb, 0xeb, 0xeb, 0xeb, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0x18, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0x18, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x18, 0xeb, 0xeb, 0xeb, 0xeb, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0x19, 0x19, 0x19, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

const unsigned char kSTOPPED_ICON[] =
{
	0xff, 0x18, 0x19, 0x18, 0x19, 0x18, 0x18, 0x19, 0x18, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

const unsigned char kEJECTED_ICON[] =
{
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0x11, 0x00, 0x11, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x11, 0x00, 0x00, 0x00, 0x11, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

const unsigned char kUNKNOWN_ICON[] =
{
	0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x11, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0x18, 0x00, 0x00, 0xff, 0x18, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0x18, 0x00, 0x00, 0xff, 0x18, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x11, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};


/*=================================================================*/

TMiniStatusWindow::TMiniStatusWindow(BView* parent, int32 length)
	: BWindow(BRect(-100,-100,-99,-99), "status",
		B_NO_BORDER_WINDOW_LOOK, B_FLOATING_ALL_WINDOW_FEEL,
		B_NOT_RESIZABLE | B_NOT_ZOOMABLE | B_AVOID_FRONT | B_AVOID_FOCUS),
	  fParent(parent)
{
	BRect r(Bounds());
	r.InsetBy(-1, -1);
	
	//	the time is multiplied by 10 because the pulse factor is 1/10 of a second
	fStatsView = new TStatusRegion(parent, r, length * 10);
	AddChild(fStatsView);
	
	SetPulseRate(100000);
	Show();
}

/*-----------------------------------------------------------------*/

void TMiniStatusWindow::MessageReceived(BMessage* msg)
{
	switch(msg->what)
	{
		case 'clos':
			Hide();
			fStatsView->SetAutoShow(false);
			fStatsView->SetTimeRemaining(0);
			Lock();
			Quit();
			break;

		default:
			BWindow::MessageReceived(msg);
			break;
	}
}

/*-----------------------------------------------------------------*/

bool TMiniStatusWindow::QuitRequested()
{
	return true;
}


/*=================================================================*/

TStatusRegion::TStatusRegion(BView* parent, BRect rect, int32 length)
	: BView(rect, "", B_FOLLOW_ALL, B_WILL_DRAW | B_PULSE_NEEDED),
	  fPlayerCount(0),
	  fTimeRemaining(length),
	  fParent(parent)
{
	fAutoShow = (length > 0);

	SetViewColor(kVIEW_COLOR);
	SetFont(be_plain_font);
	SetFontSize(10);

	fReplicantFrame = fParent->Frame();
	if (fParent->Window()->Lock())
	{
		// this is pretty wacked, but...
		// we need to know the location of the view attached to the window (deskbar)
		// which is now, not the replicant tray
		fWindowFrame = fParent->Window()->Frame();
		if (fParent->Parent()->Parent())
			fParentFrame = fParent->Parent()->Parent()->Frame();
		else
			fParentFrame = fParent->Parent()->Frame();
		fParent->Window()->Unlock();
	}
	fIcon = new BBitmap(BRect(0, 0, kICON_WIDTH, kICON_HEIGHT), B_COLOR_8_BIT);
}

/*-----------------------------------------------------------------*/

TStatusRegion::~TStatusRegion()
{
	track_data	track;

	delete fIcon;

	fIter = fTrack.begin();
	while (fTrack.size())
	{
		track = *fTrack.begin();
		free(track.name);
		fTrack.erase(fTrack.begin());
	}
}

/*-----------------------------------------------------------------*/

void TStatusRegion::AttachedToWindow()
{
	BMessenger*	messenger;

	messenger = new BMessenger(kCD_DAEMON_NAME, -1, NULL);
	if (messenger->IsValid())
		messenger->SendMessage(eCDDaemonPlayerCount, this);
	else
		be_roster->Launch(kCD_DAEMON_NAME);
	delete messenger;
}

/*-----------------------------------------------------------------*/

void TStatusRegion::Draw(BRect )
{
	float		line;
	float		offset = 0;
	int32		index = 0;
	BFont		font;
	BRect		r = Bounds();
	font_height	finfo;
	track_data	track;

	r.InsetBy(1, 1);
	SetHighColor(0, 0, 0, 255);
	StrokeRect(r);
	r.InsetBy(1, 1);
	SetHighColor(kLIGHT_VIEW_COLOR);
	StrokeLine(BPoint(r.left, r.bottom), BPoint(r.left, r.top));
	StrokeLine(BPoint(r.left + 1, r.top), BPoint(r.right - 1, r.top));
	SetHighColor(kDARK_VIEW_COLOR);
	StrokeLine(BPoint(r.right, r.top), BPoint(r.right, r.bottom));
	StrokeLine(BPoint(r.right - 1, r.bottom), BPoint(r.left + 1, r.bottom));

	r.InsetBy(1, 1);
	SetHighColor(kVIEW_COLOR);
	FillRect(r);
		
	SetHighColor(kTEXT_COLOR);
	SetLowColor(kVIEW_COLOR);

	GetFont(&font);
	font.GetHeight(&finfo);
	line = finfo.ascent + finfo.descent + finfo.leading + kVER_MARGIN;

	if (fTrack.size() > 1)
	{
		if (fTrack.size() > 9)
			offset = font.StringWidth("00: ");
		else
			offset = font.StringWidth("0: ");
	}

	for (fIter = fTrack.begin(); fIter != fTrack.end(); ++fIter)
	{
		char*	bits = NULL;

		if (offset)
		{
			char	str[16];

			sprintf(str, "%d:", (int)index + 1);
			MovePenTo(kHOR_MARGIN + offset - font.StringWidth(str), (line * index) + kVER_MARGIN + finfo.ascent);
			DrawString(str);
		}

		track = *fIter;
		switch (track.status)
		{
			case ePlayerStatusUnknown:
				bits = (char*)kUNKNOWN_ICON;;
				break;

			case ePlayerStatusEmpty:
			case ePlayerStatusDoorOpen:
				bits = (char*)kEJECTED_ICON;
				break;

			case ePlayerStatusStopped:
				bits = (char*)kSTOPPED_ICON;
				break;

			case ePlayerStatusPlaying:
				bits = (char*)kPLAYING_ICON;
				break;

			case ePlayerStatusPaused:
				bits = (char*)kPAUSED_ICON;
				break;

			case ePlayerStatusRipping:
				bits = (char*)kRIPPING_ICON;
				break;
		}
		if (bits)
		{
			fIcon->SetBits(bits, fIcon->BitsLength(), 0, B_COLOR_8_BIT);
			SetDrawingMode(B_OP_OVER);
			DrawBitmap(fIcon, BPoint(offset + kHOR_MARGIN + 3, (line * index) + 5));
		}

		MovePenTo(offset + kHOR_MARGIN + kICON_WIDTH + 6, (line * index) + kVER_MARGIN + finfo.ascent);
		DrawString(track.name);
		index++;
	}
}

/*-----------------------------------------------------------------*/

void TStatusRegion::MessageReceived(BMessage* msg)
{
	switch (msg->what)
	{
		case eCDDaemonPlayerCount:
			{
				int32		loop;
				track_data	track;

				msg->FindInt32(kCD_DAEMON_PLAYER_COUNT, &fPlayerCount);
				track.name = NULL;
				track.status = ePlayerStatusUnknown;
				for (loop = 0; loop < fPlayerCount; loop++)
					fTrack.insert(fTrack.end(), track);
			}
			break;

		case eCDDaemonPlayerData:
			{
				bool							dirty = false;
				const char*						tracks;
				int32							index = 0;
				const cd_daemon_player_data*	player;
				track_data						track;
				ssize_t							size;

				fIter = fTrack.begin();
				while (msg->FindData(kCD_DAEMON_PLAYER_DATA, B_RAW_TYPE, index, (const void**)&player, &size) == B_NO_ERROR)
				{
					track = *fIter;
					track.status = player->status;
					tracks = NULL;
					msg->FindString(kCD_DAEMON_PLAYER_TRACK_LIST, index, &tracks);
					if (strlen(tracks) == 0)
						tracks = 0;
					if (UpdateText(&track, player, tracks))
						dirty = true;
					*fIter = track;
					index++;
					fIter++;
				}
				if (dirty)
				{
					UpdateWindow();
					Draw(Bounds());
				}
			}
			break;

		default:
			BView::MessageReceived(msg);
	}
}

/*-----------------------------------------------------------------*/

void TStatusRegion::Pulse(void)
{
	BView::Pulse();

	if (fAutoShow)
	{
		fTimeRemaining--;
		if ((fAutoShow) && (fTimeRemaining <= 0) && (fParent))
		{
			Window()->PostMessage('clos');
			return;
		}
	}

	if (fPlayerCount)
	{
		BMessenger	*messenger;

		messenger = new BMessenger(kCD_DAEMON_NAME, -1, NULL);
		if (messenger->IsValid())
			messenger->SendMessage(eCDDaemonPlayerData, this);
		else
			be_roster->Launch(kCD_DAEMON_NAME);
		delete messenger;
	}
}

/*-----------------------------------------------------------------*/

bool TStatusRegion::UpdateText(track_data* track, const cd_daemon_player_data* player, const char* tracks)
{
	char*	name = NULL;

	switch (player->status)
	{
		case ePlayerStatusUnknown:
			name = (char*)malloc(strlen(kUNKNOWN) + 1);
			strcpy(name, kUNKNOWN);
			break;

		case ePlayerStatusEmpty:
			name = (char*)malloc(strlen(kEMPTY) + 1);
			strcpy(name, kEMPTY);
			break;

		case ePlayerStatusDoorOpen:
			name = (char*)malloc(strlen(kOPEN) + 1);
			strcpy(name, kOPEN);
			break;

		case ePlayerStatusStopped:
			if (tracks)
			{
				int32	index = 0;

				while (tracks[index] != '\n')
					index++;
				name = (char*)malloc(index + 1);
				strncpy(name, tracks, index);
				name[index] = 0;
			}
			else
			{
				name = (char*)malloc(strlen(kSTOPPED) + 1);
				strcpy(name, kSTOPPED);
			}
			break;

		case ePlayerStatusPlaying:
		case ePlayerStatusPaused:
		case ePlayerStatusRipping:
			if (tracks)
			{
				char*		tmp;
				const char*	offset;
				int32		index = 0;
				int32		loop;
				int32		current = player->current_track;

				for (loop = 0; loop < current; loop++)
				{
					while (tracks[index] != '\n')
						index++;
					index++;
				}
				offset = &tracks[index];
				index = 0;
				while (offset[index] != '\n')
					index++;
				tmp = (char*)malloc(index + 1);
				strncpy(tmp, offset, index);
				tmp[index] = 0;
				name = (char*)malloc(index + 4 + 1);
				sprintf(name, "%d. %s", (int)player->current_track, tmp);
				free(tmp);
			}
			else
			{
				name = (char*)malloc(strlen(kTRACK) + 2 + 1);
				sprintf(name, "%s %d", kTRACK, (int)player->current_track);
			}
			break;
	}

	if ((!track->name) || (strcmp(name, track->name) != 0))
	{
		free(track->name);
		track->name = name;
		return true;
	}
	else
		free(name);
	return false;
}

/*-----------------------------------------------------------------*/

void TStatusRegion::UpdateWindow()
{
	float		currentWidth = Window()->Bounds().Width();
	float		currentHeight = Window()->Bounds().Height();
	float		desiredWidth = (kHOR_MARGIN * 2) + kICON_WIDTH + 6;
	float		desiredHeight;
	float		max_width = 0;
	BFont		font;
	font_height	finfo;
	track_data	track;

	GetFont(&font);

	for (fIter = fTrack.begin(); fIter != fTrack.end(); ++fIter)
	{
		track = *fIter;
		if ((track.name) && (font.StringWidth(track.name) > max_width))
			max_width = font.StringWidth(track.name);
	}
	desiredWidth += max_width;
	if (fTrack.size() > 1)
	{
		if (fTrack.size() > 9)
			desiredWidth += font.StringWidth("00: ");
		else
			desiredWidth += font.StringWidth("0: ");
	}

	font.GetHeight(&finfo);
	desiredHeight = (finfo.ascent + finfo.descent + finfo.leading + kVER_MARGIN) * fPlayerCount;
	desiredHeight += kVER_MARGIN - 1;

	if ((desiredWidth != currentWidth) || (desiredHeight != currentHeight))
	{
		if (Window()->Lock())
		{
			bool				expanded;
			BDeskbar			db;
			deskbar_location	dbPosition = db.Location(&expanded);
			BRect				dbFrame = db.Frame();
			BPoint				pt;

			Window()->ResizeTo(desiredWidth, desiredHeight);

			pt.x = dbFrame.right - fParentFrame.Width();
			pt.x -= desiredWidth;
			pt.x += fReplicantFrame.left + (fReplicantFrame.Width()/2);

			if ((dbPosition == B_DESKBAR_TOP) || (dbPosition == B_DESKBAR_RIGHT_TOP ))
				pt.y = fParentFrame.bottom - 1;
			else if (dbPosition == B_DESKBAR_LEFT_TOP)
			{
				pt.x = fParentFrame.left + fReplicantFrame.left + (fReplicantFrame.Width()/2);
				pt.y = fParentFrame.bottom - 1;
			}
			else if (dbPosition == B_DESKBAR_BOTTOM)
				pt.y = dbFrame.top - desiredHeight + 1;
			else if (dbPosition == B_DESKBAR_RIGHT_BOTTOM)
				pt.y = dbFrame.top + fParentFrame.Height() + 3;
			else if (dbPosition == B_DESKBAR_LEFT_BOTTOM)
			{
				pt.x = fParentFrame.left + fReplicantFrame.left + (fReplicantFrame.Width()/2);
				pt.y = dbFrame.top + fParentFrame.Height() + 3;
			}					

			Window()->MoveTo(pt);
			Window()->Unlock();
		}
	}
}
