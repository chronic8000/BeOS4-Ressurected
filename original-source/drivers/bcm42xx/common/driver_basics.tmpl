/*
 * driver_basics template
 * Copyright (c) 2000 Be, Inc.	All Rights Reserved
 * written by Peter Folk <pfolk@be.com>
 */

#define kDevName "foo"   // the device name
#define kDevDir  "bar"   // the device dir
// devices will appear as /dev/bar/foo/...

#define DEBUG             // if you want debug output
#define MAX_DEVICES 4     // instances of this driver, max
#define SINGLE_OPEN       // if only one open session per
                          // device is allowed at a time

typedef struct {
	// Required by driver_basics.h
	int32     devID;       // device identifier: 0-MAX_DEVICES
	pci_info  *pciInfo;    // info about this device
	uint32    debug;       // debugging level mask
	
	// Your per-device data items go here...
} dev_info_t;
#include <driver_basics.h>
#include <driver_basics.c>

/*
 * check_device
 *
 * Return B_OK iff dev is supported by this driver.
 */
static status_t check_device(const pci_info* dev)
{
	return B_OK;
}

/*
 * open_device
 *
 * Fill in dev, given flags, and return B_OK if everything went
 * as planned.
 */
static status_t open_device(dev_info_t *dev, uint32 flags)
{
	return B_OK;
}

/*
 * close_device
 *
 * Tell all pending operations to abort and unblock all blocked ops.
 * DO NOT deallocate anything, as some ops could still be pending.
 */
static status_t close_device(dev_info_t *dev)
{
	return B_OK;
}

/*
 * free_device
 *
 * All operations have completed, no more will be called.  De-
 * allocate anything you allocated (in open() or elsewhere).
 */
static status_t free_device(dev_info_t *dev)
{
	return B_OK;
}

/*
 * control_device
 *
 * Handle ioctl().
 */
static status_t
control_device(dev_info_t *dev, uint32 msg,void *buf, size_t len)
{
	return B_ERROR;
}

/*
 * read_device
 *
 * Handle read().
 */
static status_t
read_device( dev_info_t *dev, off_t pos, void *buf, size_t *len)
{
	*len=0;
	return B_OK;
}

/*
 * write_device
 *
 * Handle write().
 */
static status_t
write_device(dev_info_t *dev, off_t pos, const void *buf, size_t *len)
{
	*len=0;
	return B_OK;
}
