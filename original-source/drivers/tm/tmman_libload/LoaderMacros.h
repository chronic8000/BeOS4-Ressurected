/*
 *  +-------------------------------------------------------------------+
 *  | Copyright (c) 1995,1996,1997 by Philips Semiconductors.           |
 *  |                                                                   |
 *  | This software  is furnished under a license  and may only be used |
 *  | and copied in accordance with the terms  and conditions of such a |
 *  | license  and with  the inclusion of this  copyright notice.  This |
 *  | software or any other copies of this software may not be provided |
 *  | or otherwise  made available  to any other person.  The ownership |
 *  | and title of this software is not transferred.                    |
 *  |                                                                   |
 *  | The information  in this software  is subject  to change  without |
 *  | any  prior notice  and should not be construed as a commitment by |
 *  | Philips Semiconductors.                                           |
 *  |                                                                   |
 *  | This  code  and  information  is  provided  "as is"  without  any |
 *  | warranty of any kind,  either expressed or implied, including but |
 *  | not limited  to the implied warranties  of merchantability and/or |
 *  | fitness for any particular purpose.                               |
 *  +-------------------------------------------------------------------+
 *
 *  Module name              : LoaderMacros.h    1.38
 *
 *  Module type              : SPECIFICATION
 *
 *  Title                    : Local macros for loader lib implementation
 *
 *  Last update              : 22:23:24 - 98/02/12
 *
 *  Description              :  
 *
 */

#ifndef  LoaderMacros_INCLUDED
#define  LoaderMacros_INCLUDED

/*------------------------------ Macros --------------------------------------*/

/*
 * Some simple macros for constructing 
 * sets and mappings. They all have the
 * specified number of buckets. This number
 * has been chosen fairly large, because
 * manipulating 'large' object files (>30000
 * named items) has appeared to be dominated
 * by linear bucket search:
 */

#define BUCKETS               5000     /* nr of buckets in all mappings */

#define NEW_SET(equal,hash) \
     Lib_Set_create( 				\
               (Lib_Local_BoolResFunc)equal, 	\
               (Lib_Local_EltResFunc)hash, 	\
               BUCKETS 				\
     )


#define NEW_MAPPING(equal,hash) \
     Lib_Mapping_create( 			\
               (Lib_Local_BoolResFunc)equal, 	\
               (Lib_Local_EltResFunc)hash, 	\
               BUCKETS 				\
     )


/*
 * The implementation of the object reader and 
 * the object writer performs almost identical
 * actions on the various system objects. There are about
 * 12 different system types, and in order to prevent
 * the duplication of a lot of source code, the
 * reader and writer have been implemented by means
 * of macro iterators over all sections. The finally
 * compiled code hence is generated by the preprocessor,
 * and many functions need only have been defined
 * in the form of a macro template. 
 * This relies on a strict naming scheme. Various
 * general macros whereunder the iterators are defined
 * below:
 */

/* 
 * Definitions to complete naming scheme:
 */

#define TMObj_String      String
#define TMObj_String_Rec  Char


/* 
 * Name generators for different functions and macros:
 */
#define ID(SECTION)                    TMObj_##SECTION##_Section
#define OBJ(SECTION)                   TMObj_##SECTION
#define REC(SECTION)                   TMObj_##SECTION##_Rec
#define PACK_FUN(SECTION,MODE)         Pack_##SECTION##_##MODE
#define PACK_MACRO(SECTION)            Pack_##SECTION##_Object
#define PUTBACK_FUN(SECTION)           Putback_##SECTION
#define UNPACK_MACRO(SECTION)          Unpack_##SECTION##_Object
#define PUTBACK_MACRO(SECTION)         Putback_##SECTION##_Object
#define OBJINFO(SECTION)               objinfo[ID(SECTION)]
#define RELOCATE(SECTION) 	       Relocate_##SECTION
#define MODAL_UNPACK_FUN(SECTION,MODE) Unpack_##SECTION##_##MODE
#define UNPACK_FUN(SECTION)            Unpack_##SECTION


#define EQUAL(SECTION)                SECTION##_equal
#define HASH(SECTION)                 SECTION##_hash
#define MARK(SECTION)                 SECTION##_mark
#define REMARK(SECTION)               SECTION##_remark


/*
 * Encoding/decoding macros for 
 * system section identifiers, 
 * to be used as (pseudo-) section 
 * pointers in markers. The decoding
 * is needed to keep them separate 
 * from 'legal' section pointers.
 * And the special handling of these
 * is used because system sections
 * do not yet exist when manipulating
 * in-memory object structures (only
 * their data is there).
 */
#define IS_SSID(s)                                      ( ((Int)s)  & 0x1 )
#define ENCODE_SSID(id)      ( (TMObj_Section          )( ((id)<<1) | 0x1 ) )
#define DECODE_SSID(s)       ( (TMObj_System_Section_Id)( ((Int)(s))>>1   ) )


#define CONS(a,b)  a,b




/*
 * The following defines a macro for performing 
 * a specified operation on the contents of
 * particular system sections:
 */

#define TRAVERSE_SYSTEM_SECTION(SECTION,section,MACRO,arg1,arg2,arg3) \
    {										   \
       if (section != Null) {							   \
           Address      __sectionbase;						   \
           OBJ(SECTION) restrict __base; 				           \
           OBJ(SECTION) restrict __ceiling;   					   \
										   \
	   __sectionbase = (Address)(section->bytes);		   		   \
	   __base        = (Pointer) __sectionbase;                       	   \
	   __ceiling     = (Pointer)(__sectionbase + section->size);               \
										   \
	   while (__base < __ceiling) {					           \
	       MACRO(__base,arg1,arg2,arg3);				           \
	       __base++;						           \
	   }									   \
       }									   \
    }



/*
 * The following define a number of system section
 * iteration macros. A number of them are provided
 * for different purposes, but defining them here
 * isolates most of the knowledge of which sections
 * exits.
 *   PACK:    containing the sections which indeed
 *            possess contents which are to be packed/unpacked.
 *            For the downloaders it is essential that
 *            all references are unpacked last; they depend on this
 *            because they combine unpacking with relocation
 *   TRGLD_UNPACK_:    
 *            containing the sections which indeed
 *            possess contents which are to be packed/unpacked,
 *            excluding system data which is not needed by
 *            the dynamic loader.
 *            For the downloaders it is essential that
 *            all references are unpacked last; they depend on this.
 *            because they combine unpacking with relocation.
 *            NB: references are streamed during target downloading
 *                this guarantees that they are processed last,
 *                *and* they can be removed from the unpack phase.
 *   PUTBACK: used in tmld, contains the sections whose 
 *            contents must be added to the output object
 *            under construction. NOTE: for proper working
 *            of tmld it is essential that the Symbol
 *            system section is processed before all other
 *            system sections which refer to symbols
 *            (Symbol_Reference, for the moment). 
 *            This guarantees that all symbol definitions
 *            are known, and hence all symbol users
 *            can just access the new, merged symbols.
 *   ENUM:    containing the sections whose contents' order
 *            need not be preserved. Only the order of
 *            section units need be preserved to maintain
 *            the order of linking.
 *   FULL:    all sections.
 *            NOTE: **IN THE ORDER OF DEFINITION IN TMOBJ.H**
 */

#define GEN_PACK_SECTION_CODE(MACRO,arg1,arg2) \
    MACRO(	Scatter,			arg1,arg2)	\
    MACRO(	Scatter_Source,			arg1,arg2)	\
    MACRO(	Symbol,				arg1,arg2)	\
 /* MACRO(	Section,			arg1,arg2) */   \
    MACRO(	External_Module,		arg1,arg2)	\
 /* MACRO(	String,				arg1,arg2) */	\
    MACRO(	SectionUnit,			arg1,arg2)	\
 /* MACRO(	Scatter_Dest,			arg1,arg2) */	\
    MACRO(	Symbol_Reference,		arg1,arg2)	\
    MACRO(	Marker_Reference,		arg1,arg2)	\
    MACRO(	JTab_Reference,			arg1,arg2)	\
    MACRO(	FromDefault_Reference,		arg1,arg2)	\
    MACRO(	DefaultToDefault_Reference,	arg1,arg2)	\

#define GEN_UNPACK_SECTION_CODE(MACRO,arg1,arg2) \
 /* MACRO(	Scatter_Dest,			arg1,arg2) */	\
    MACRO(	Scatter_Source,			arg1,arg2)	\
    MACRO(	Scatter,			arg1,arg2)	\
    MACRO(	Symbol,				arg1,arg2)	\
 /* MACRO(	Section,			arg1,arg2) */   \
    MACRO(	External_Module,		arg1,arg2)	\
 /* MACRO(	String,				arg1,arg2) */	\
    MACRO(	SectionUnit,			arg1,arg2)	\
    MACRO(	Symbol_Reference,		arg1,arg2)	\
    MACRO(	Marker_Reference,		arg1,arg2)	\
    MACRO(	JTab_Reference,			arg1,arg2)	\
    MACRO(	FromDefault_Reference,		arg1,arg2)	\
    MACRO(	DefaultToDefault_Reference,	arg1,arg2)	\

#define GEN_TRGLD_UNPACK_SECTION_CODE(MACRO,arg1,arg2) \
    MACRO(	Scatter,			arg1,arg2)	\
    MACRO(	Scatter_Source,			arg1,arg2)	\
    MACRO(	Symbol,				arg1,arg2)      \
 /* MACRO(	Section,			arg1,arg2) */   \
    MACRO(	External_Module,		arg1,arg2)	\
 /* MACRO(	String,				arg1,arg2) */	\
 /* MACRO(	SectionUnit,			arg1,arg2) */   \
 /* MACRO(	Scatter_Dest,			arg1,arg2) */	\
 /* MACRO(	Symbol_Reference,		arg1,arg2) */	\
 /* MACRO(	Marker_Reference,		arg1,arg2) */	\
    MACRO(	JTab_Reference,			arg1,arg2)   	\
 /* MACRO(	FromDefault_Reference,		arg1,arg2) */	\
 /* MACRO(	DefaultToDefault_Reference,	arg1,arg2) */	\

/* SEE ABOVE NOTE */
#define GEN_PUTBACK_SECTION_CODE(MACRO,arg1,arg2) \
 /* MACRO(	Scatter,			arg1,arg2) */	\
 /* MACRO(	Scatter_Source,			arg1,arg2) */	\
    MACRO(	Symbol,				arg1,arg2)	\
 /* MACRO(	Section,			arg1,arg2) */	\
 /* MACRO(	External_Module,		arg1,arg2) */	\
 /* MACRO(	String,				arg1,arg2) */	\
    MACRO(	SectionUnit,			arg1,arg2)	\
 /* MACRO(	Scatter_Dest,			arg1,arg2) */	\
    MACRO(	Symbol_Reference,		arg1,arg2)	\
    MACRO(	Marker_Reference,		arg1,arg2)	\
    MACRO(	JTab_Reference,			arg1,arg2)	\
    MACRO(	FromDefault_Reference,		arg1,arg2)	\
    MACRO(	DefaultToDefault_Reference,	arg1,arg2)	\


#define GEN_ENUM_SECTION_CODE(MACRO,arg1,arg2) \
    MACRO(	Scatter,			arg1,arg2)	\
    MACRO(	Scatter_Source,			arg1,arg2)	\
    MACRO(	Symbol,				arg1,arg2)	\
    MACRO(	Section,			arg1,arg2)	\
    MACRO(	External_Module,		arg1,arg2)	\
    MACRO(	String,				arg1,arg2) 	\
 /* MACRO(	SectionUnit,			arg1,arg2) */	\
    MACRO(	Scatter_Dest,			arg1,arg2)	\
    MACRO(	Symbol_Reference,		arg1,arg2)	\
    MACRO(	Marker_Reference,		arg1,arg2)	\
    MACRO(	JTab_Reference,			arg1,arg2)	\
    MACRO(	FromDefault_Reference,		arg1,arg2)	\
    MACRO(	DefaultToDefault_Reference,	arg1,arg2)	\


#define GEN_FULL_SECTION_CODE(MACRO,arg1,arg2) \
    MACRO(	Scatter,			arg1,arg2)	\
    MACRO(	Scatter_Source,			arg1,arg2)	\
    MACRO(	Symbol,				arg1,arg2)	\
    MACRO(	Section,			arg1,arg2)	\
    MACRO(	External_Module,		arg1,arg2)	\
    MACRO(	String,				arg1,arg2)  	\
    MACRO(	SectionUnit,			arg1,arg2)	\
    MACRO(	Scatter_Dest,			arg1,arg2)	\
    MACRO(	Symbol_Reference,		arg1,arg2)	\
    MACRO(	Marker_Reference,		arg1,arg2)	\
    MACRO(	JTab_Reference,			arg1,arg2)	\
    MACRO(	FromDefault_Reference,		arg1,arg2)	\
    MACRO(	DefaultToDefault_Reference,	arg1,arg2)	\






/*
 * Different versions of endianness swapping, and
 * of replacing a value with its swapped version
 * (I = Int, A= Address).
 */

#define XIENDIAN_SWAP2(x)   (x)= LIENDIAN_SWAP2(x);
#define XIENDIAN_SWAP4(x)   (x)= LIENDIAN_SWAP4(x);
#define XAENDIAN_SWAP4(x)   (x)= LAENDIAN_SWAP4(x);

#define SWAP24(x) \
           (  ( ( ((UInt)(x)) & 0x0000ff00 ) <<  8 ) \
           |  ( ( ((UInt)(x)) & 0x00ff0000 ) >>  8 ) \
           |  ( ( ((UInt)(x)) & 0xff000000 ) >> 24 ) \
           )

/*
 * A packed pointer is the representation of
 * pointers from system objects to other system
 * objects. The first byte defines the lifetime
 * of the referred system object, the next three
 * define the offset in its corresponding section/
 * (which is the section corresponding with the
 * type of the referred object and the lifetime).
 * A special lifetime is Null lifetime (0), reserved 
 * for Null pointers. Another is the system lifetime,
 * reserved for pointers to internal sections.
 */

#define PACKED_POINTER(lifetime,offset) \
        ((Pointer)((lifetime)<<24 | (offset)))

#define LIFETIME_OF(x) \
        ((TMObj_Section_Lifetime)(((UInt32)(x))>>24))

#define OFFSET_OF(x) \
        ((TMObj_Section_Lifetime)(((UInt32)(x))&0x00ffffff))



/*
 * Specific unpack macros, 
 *  utt= UnpackTranslationTable, ModuleBuild.c
 *     this is a matrix which contains the start and
 *     end address of each system section/lifetime section.
 */
#define UNPACK16_SWAP(x)    XIENDIAN_SWAP2(x);
#define UNPACK16_NOSWAP(x)  ;

#define UNPACK32_SWAP(x)    XIENDIAN_SWAP4(x);
#define UNPACK32_NOSWAP(x)  ;

#define UNPACK(SECTION, object,utt,MODE)    UNPACK_##MODE(SECTION,object,utt)
#define UNPACK16(object,utt,MODE)           UNPACK16_##MODE(object)
#define UNPACK32(object,utt,MODE)           UNPACK32_##MODE(object)

/*
 * Specific pack macros, 
 *   ptt= PackTranslationTable, ModuleBuild.c 
 *      this is a table which for this purpose contains a
 *      field which indicates a difference in endianness 
 *      between the current machine and the one in which
 *      the object should be stored.
 *   collection_rec= CollectionRec, ModuleBuild.c
 *      this is a table which contains a translation of
 *      each memory pointer to a PACKED_POINTER (see above)
 */

#define PACK16(x,ptt,collection_rec) \
           	if ((ptt)->endian_difference) XIENDIAN_SWAP2(x);

#define PACK32(x,ptt,collection_rec) \
           	if ((ptt)->endian_difference) XIENDIAN_SWAP4(x);

#define PACK(SECTION,x,ptt,collection_rec) \
           if ((x) != Null) {                                           \
		(x)= Lib_Mapping_apply( 				\
                             (collection_rec)->OBJINFO(SECTION),	\
                             (x)					\
                     );							\
		if ((ptt)->endian_difference) XAENDIAN_SWAP4(x);        \
	   }

#define LIFE(x,id,ptt,collection_rec) \
	(((UInt)Lib_Mapping_apply( 			\
                      (collection_rec)->objinfo[id],	\
                      (Pointer)(x)			\
         ) >> 24) )					\



#endif /* LoaderMacros_INCLUDED */
     
   
