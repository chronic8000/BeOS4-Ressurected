/*
 *  +-------------------------------------------------------------------+
 *  | Copyright (c) 1995,1996,1997 by Philips Semiconductors.           |
 *  |                                                                   |
 *  | This software  is furnished under a license  and may only be used |
 *  | and copied in accordance with the terms  and conditions of such a |
 *  | license  and with  the inclusion of this  copyright notice.  This |
 *  | software or any other copies of this software may not be provided |
 *  | or otherwise  made available  to any other person.  The ownership |
 *  | and title of this software is not transferred.                    |
 *  |                                                                   |
 *  | The information  in this software  is subject  to change  without |
 *  | any  prior notice  and should not be construed as a commitment by |
 *  | Philips Semiconductors.                                           |
 *  |                                                                   |
 *  | This  code  and  information  is  provided  "as is"  without  any |
 *  | warranty of any kind,  either expressed or implied, including but |
 *  | not limited  to the implied warranties  of merchantability and/or |
 *  | fitness for any particular purpose.                               |
 *  +-------------------------------------------------------------------+
 *
 *  Module name              : DynamicLoader.h    1.19
 *
 *  Module type              : SPECIFICATION
 *
 *  Title                    : Programming interface to dynamic loader
 *
 *  Last update              : 13:21:30 - 98/04/23
 *
 *  Description              :  
 *                   This header file specifies the programming
 *                   interface to the dynamic loader. The interface
 *                   is restricted: it allows loading of a named
 *                   code segment returning a handle, and unloading
 *                   a code segment via its name.
 *
 *                   Loading a code segment automatically loads all
 *                   other code segments which were specified with 
 *                   '-bimmediate' during the final link stage
 *                   of the loaded segment. Also, apart from loading,
 *                   all symbol references to and from already resident
 *                   code segments are resolved.
 * 
 *                   Unloading of a code segment is a particularly 
 *                   unsafe operation: it must be guaranteed that no
 *                   references from other code segments to *variables*
 *                   in the unloaded segments exist. References to 
 *                   *functions* are safe, because the unloader replaces
 *                   these with references to local placeholders (stubs).
 *
 *                   Calls to the load and unload functions exported
 *                   by this module maintain a simple reference count
 *                   for each loaded code segment: each call to DynLoad_load  
 *                   increments the reference count of the corresponding code 
 *                   segment, and each DynLoad_unload decrements it, with an
 *                   actual unload from memory when the count drops to zero.
 *                   Although a hidden call to DynLoad_load is used by function 
 *                   stubs generated by tmld for implicit code segment 
 *                   loading, function stubs do *not* increment the reference
 *                   counts for the duration of the call; hence, it is the
 *                   responsibility of the user to not attempt to unload 
 *                   a code segment while any of its code is still being
 *                   executed. 
 *                   
 *
 *                   The functions specified in this header file are
 *                   reentrant, that is, they are guarded against
 *                   parallel invokation by different threads/tasks/processes.
 */

#ifndef  DynamicLoader_INCLUDED
#define  DynamicLoader_INCLUDED


/*---------------------------- Includes --------------------------------------*/
#ifdef __TCS__
#include <tmlib/tmtypes.h>
#else
#include "tmtypes.h"
#endif

#if	defined(__cplusplus)
extern	"C"	{
#endif	/* defined(__cplusplus) */

/*--------------------------- Definitions ------------------------------------*/

/*
 * Result status values for the exported functions:
 */

typedef enum {
       DynLoad_OK                           =  0,

       DynLoad_FileNotFound                 =  1,
       DynLoad_InsufficientMemory           =  2,
       DynLoad_InconsistentObject           =  3,
       DynLoad_UnknownObjectVersion         =  4,
       DynLoad_WrongEndian                  =  5,
       DynLoad_WrongChecksum                =  6,
       DynLoad_NotUnloadable                =  7,
       DynLoad_UnresolvedSymbol             =  8,
       DynLoad_NotADll                      =  9,
       DynLoad_NotAnApp                     = 10,
       DynLoad_NotPresent                   = 11,
       DynLoad_StillReferenced              = 12,
       DynLoad_StackOverflow
} DynLoad_Status;



/*
 * Representation of loaded code segment:
 */


typedef struct {
    String      name;
    Pointer     start;
} *DynLoad_Code_Segment_Handle;


typedef Pointer (*DynLoad_MallocFun)(UInt);
typedef void    (*DynLoad_FreeFun)(Pointer);

typedef void (*DynLoad_ErrorFun)(DynLoad_Status,String);


/*--------------------------- Functions --------------------------------------*/

/* Don't watch */
#define DynLoad_load_application          TMTrgLoader_load_application
#define DynLoad_unload_application        TMTrgLoader_unload_application
#define DynLoad_bind_dll                  TMTrgLoader_bind_dll
#define DynLoad_unbind_dll                TMTrgLoader_unbind_dll
#define DynLoad_unload_dll                TMTrgLoader_unload_dll
#define DynLoad_unload_all                TMTrgLoader_unload_all
#define DynLoad_swap_mm                   TMTrgLoader_swap_mm
#define DynLoad_swap_stub_error_handler   TMTrgLoader_swap_stub_error_handler
#define DynLoad_bind_codeseg              TMTrgLoader_bind_codeseg
#define DynLoad_unbind_codeseg            TMTrgLoader_unbind_codeseg
/* ----------- */



/*
 * Function         : Read an application segment from file into memory, and
 *                    return a handle for subsequent operations.
 *                    Contrary to dlls, location of application object
 *                    files is not subject to any lookup mechanism;
 *                    for this reason a path must be used for specifying
 *                    the application file. The `path' here is the text string
 *                    which could be used in calls to 'open` to open the 
 *                    application object file.
 *                    Also contrary to dlls, duplicate copies of apps are 
 *                    allowed, and therefore subsequent load calls
 *                    with the same path value result in different,
 *                    independent loaded applications.
 *                    The transfer address of a loaded application 
 *                    can be found in the `start' field of the returned
 *                    module descriptor. Loaded applications can be unloaded
 *                    by means of a call to DynLoad_unload_segment.
 * Parameters       : path   (I)  Name of executable file to be loaded.
 *                    result (O)  Returned handle, or undefined when
 *                                result unequal to DynLoad_OK.
 * Function Result  : DynLoad_OK
 *                    DynLoad_FileNotFound 
 *                    DynLoad_InsufficientMemory 
 *                    DynLoad_InconsistentObject 
 *                    DynLoad_UnknownObjectVersion 
 *                    DynLoad_WrongEndian
 *                    DynLoad_WrongChecksum 
 *                    DynLoad_UnresolvedSymbol 
 *                    DynLoad_NotAnApp 
 * Sideeffects      : Memory to hold the result  
 *                    is allocated via malloc, or via
 *                    the user specified memory manager
 *                    (see function DynLoad_swap_mm).
 */

DynLoad_Status 
    DynLoad_load_application( 
               String                          path,
               DynLoad_Code_Segment_Handle    *result
    );


/*
 * Function         : Unload specified application from memory.
 *                    This function will fail if the segment does not
 *                    correspond with an application segment, or if
 *                    the application's code is still in use 
 *                    (e.g. when it contains a still installed 
 *                    interrupt handler, or when other tasks are still
 *                    executing its code, or when it has been bound
 *                    by a call to AppModel_bind_codeseg.
 * Parameters       : segment (I)  descriptor of application to unload.
 * Function Result  : DynLoad_OK
 *                    DynLoad_NotAnApp 
 *                    DynLoad_StillReferenced
 */

DynLoad_Status 
    DynLoad_unload_application( DynLoad_Code_Segment_Handle segment );
 


/*
 * Function         : Locate specified dll, load it into memory
 *                    when not already loaded, and return a handle for 
 *                    subsequent operations. The dll is marked as
 *                    being in use, preventing it from being unloaded,
 *                    until a matching call to DynLoad_unbind_dll.
 *
 *                    Contrary to applications, which must be loaded
 *                    with complete path specification, dlls are subject
 *                    to a lookup mechanism; for this reason, no path
 *                    specification is allowed. Instead, just the base
 *                    file name need be given.
 *
 *                    DynLoad_bind_dll and DynLoad_unbind_dll maintain
 *                    a reference count. 
 *
 * Parameters       : name   (I)  Name of dll to be loaded. No path
 *                                specification is allowed.
 *                    result (O)  Returned handle, or undefined when
 *                                result unequal to DynLoad_OK.
 * Function Result  : DynLoad_OK
 *                    DynLoad_FileNotFound 
 *                    DynLoad_InsufficientMemory 
 *                    DynLoad_InconsistentObject 
 *                    DynLoad_UnknownObjectVersion 
 *                    DynLoad_WrongEndian
 *                    DynLoad_WrongChecksum 
 *                    DynLoad_UnresolvedSymbol 
 *                    DynLoad_NotADll 
 * Sideeffects      : Memory to hold the result  
 *                    is allocated via malloc, or via
 *                    the user specified memory manager
 *                    (see function DynLoad_swap_mm).
 */

DynLoad_Status 
    DynLoad_bind_dll( 
               String                          name,
               DynLoad_Code_Segment_Handle    *result
    );


/*
 * Function         : Remove usage mark from dll.
 * Parameters       : name (I)  name of dll to unbind
 * Function Result  : DynLoad_OK
 *                    DynLoad_NotPresent
 */

DynLoad_Status 
    DynLoad_unbind_dll( String  name );



/*
 * Function         : Unload specified dll from memory, 
 *                    together with all other dlls that make
 *                    'immediate' use of it. 
 *                    Unloading will fail if any of these dlls
 *                    contain code that is still in use 
 *                    (e.g. when it contains a still installed 
 *                    interrupt handler, or when other tasks are still
 *                    executing its code, or when it has been bound
 *                    by a call to AppModel_bind_codeseg or 
 *                    DynLoad_bind_dll).
 * Parameters       : name (I)  name of dll to unload
 * Function Result  : DynLoad_OK
 *                    DynLoad_NotPresent
 *                    DynLoad_StillReferenced
 */

DynLoad_Status 
    DynLoad_unload_dll( String  name );


/*
 * Function         : Unload all currently unused dlls.
 * Parameters       : name (I)  name of dll to unload
 * Function Result  : DynLoad_OK
 */

DynLoad_Status 
    DynLoad_unload_all( );


/*
 * Function         : Mark the code segment that contains
 *                    the specified code address as used.
 *                    DynLoad_bind_codeseg maintains a reference count. 
 * Parameters       : code (I)  code address (e.g. function ptr)
 * Function Result  : DynLoad_OK
 */

DynLoad_Code_Segment_Handle
    DynLoad_bind_codeseg( Address code );


/*
 * Function         : Mark the code segment that contains
 *                    the specified code address as no longer used.
 *                    DynLoad_bind_codeseg maintains a reference count. 
 * Parameters       : code (I)  code address (e.g. function ptr)
 * Function Result  : DynLoad_OK
 */

DynLoad_Code_Segment_Handle
    DynLoad_unbind_codeseg( Address code );


/*
 * Function         : Swap the permanent- and temporary
 *                    storage manager currently in use
 *                    by the dynamic loader.
 *                    Note: this function is for system's
 *                    purposes only, and should be called
 *                    before the dynamic loader has been active.
 * Parameters       : perm_malloc (IO)  malloc + free functions for
 *                    perm_free   (IO)    allocating storage for loaded 
 *                                         code segments
 *                    temp_malloc (IO)  malloc + free functions for
 *                    temp_free   (IO)    allocating storage for working 
 *                                         memory during dynamic loading
 */

void 
    DynLoad_swap_mm( 
         DynLoad_MallocFun *perm_malloc,
         DynLoad_FreeFun   *perm_free,
         DynLoad_MallocFun *temp_malloc,
         DynLoad_FreeFun   *temp_free
    );



/*
 * Function         : Swap the (global) error handler that is to be
 *                    called upon failure in implicit dll loading
 *                    from function stubs.
 *                    Note: generally, this error handler has three options 
 *                           1) Abort the application, by calling exit,
 *                              optionally after printing a diagnostic
 *                           2) Clean up the global application state
 *                              (e.g. freeing up memory after a load
 *                               failure due to memory overflow), and return,
 *                               so that the dynamic loader can retry its 
 *                               failing load,
 *                           3) Raise an exception (or perform a longjmp in C)
 *                              so that the implicit load failure can be
 *                              handled by the application at a higher level.
 *                       ---> As long as the error handler returns, the
 *                            dynamic loader will retry the load
 * Parameters       : stub_error_handler (IO)  function stub error handler
 */

void 
    DynLoad_swap_stub_error_handler( 
         DynLoad_ErrorFun *stub_error_handler
    );



#if	defined(__cplusplus)
}
#endif	/* defined(__cplusplus) */

#endif /* DynamicLoader_INCLUDED */
